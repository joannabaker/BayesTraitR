Function currently only compatible with variable rates.")
.names = rep(.rjlognames_2,(length(.rjlog[[i]])-7) / length(.rjlognames_2))
names(.rjlog[[i]]) = c(.rjlognames_1, .names)
}
.tmp = .rjlog[[i]]
.firsthalf = data.frame(as.list(.tmp[1:7]))
.secondhalf = data.frame(split(.tmp[8:length(.tmp)], names(.tmp[8:length(.tmp)])))
.rjdf = cbind(.firsthalf,.secondhalf)
.rjlogtable = rbind(.rjlogtable,.rjdf)
}
txdef
nddef
ndheights
head(.vrlogtable)
str(.vrlogtabl)
str(.vrlogtable)
ls()
.tmp = .vrlog[[i]]
# Identify vr log block
.vrlogstart = which(grepl("^It", vrraw))
# Read full input file
vrraw = readLines(vrfile)
# Test case
vrfile = "test-001.txt.VarRates.txt"
vrraw = readLines(vrfile)
# Number of taxa
ntax = as.numeric(vrraw[1])
# Identify taxa definitions
txdef = read.table(vrfile, skip = 1, nrows = ntax,
sep = "\t",  header = F, col.names = c("TaxNo", "Tax"))
# Number of nodes
nnode = as.numeric(vrraw[ntax+2])
# Identify node definition block
nddef = vrraw[(ntax+3):(nnode+ntax+2)]
nddef = lapply(nddef, function(x)unlist(strsplit(x, split = "\t")))
names(nddef) = sapply(nddef,"[[", 1)
ndheights = sapply(nddef, "[[", 2)
nddef = sapply(nddef, "[", -c(1,2))
# Identify vr log block
.vrlogstart = which(grepl("^It", vrraw))
.vrlog = strsplit(vrraw[(.vrlogstart+1):length(vrraw)], split = "\t")
.vrlognames = unlist(strsplit(vrraw[.vrlogstart], split = "\t"))
# Tidy up and split names
.vrlognames_1 = gsub(" ", "",.vrlognames[1:7])
.vrlognames_2 = gsub(" |/", "",.vrlognames[8:length(.vrlognames)])
# Loop through vr log block and add names
.vrlogtable = NULL
for(i in 1: length(.vrlog)){
if(length(.vrlog[[i]]) == length(.vrlognames))
names(.vrlog[[i]]) = .vrlognames else{
if((length(.vrlog[[i]])-7) %% length(.vrlognames_2) != 0)
stop("vr logfile column headers not as expected.
Function currently only compatible with variable rates.")
.names = rep(.vrlognames_2,(length(.vrlog[[i]])-7) / length(.vrlognames_2))
names(.vrlog[[i]]) = c(.vrlognames_1, .names)
}
.tmp = .vrlog[[i]]
.firsthalf = data.frame(as.list(.tmp[1:7]))
.secondhalf = data.frame(split(.tmp[8:length(.tmp)], names(.tmp[8:length(.tmp)])))
.vrdf = cbind(.firsthalf,.secondhalf)
.vrlogtable = rbind(.vrlogtable,.vrdf)
}
str(.vrlogtable)
# Read full input file
vrraw = readLines(vrfile)
# Number of taxa
ntax = as.numeric(vrraw[1])
# Identify taxa definitions
txdef = read.table(vrfile, skip = 1, nrows = ntax,
sep = "\t",  header = F, col.names = c("TaxNo", "Tax"))
# Number of nodes
nnode = as.numeric(vrraw[ntax+2])
# Identify node definition block
nddef = vrraw[(ntax+3):(nnode+ntax+2)]
nddef = lapply(nddef, function(x)unlist(strsplit(x, split = "\t")))
names(nddef) = sapply(nddef,"[[", 1)
ndheights = sapply(nddef, "[[", 2)
nddef = sapply(nddef, "[", -c(1,2))
# Identify vr log block
.vrlogstart = which(grepl("^It", vrraw))
.vrlog = strsplit(vrraw[(.vrlogstart+1):length(vrraw)], split = "\t")
.vrlognames = unlist(strsplit(vrraw[.vrlogstart], split = "\t"))
.vrlognames
library(BayesTraitR)
rm(list = ls ())
library(BayesTraitR)
setwd("C:\\Programs\\tmp")
# Test case
vrfile = "test-001.txt.VarRates.txt"
test = readVR(vrfile)
test
head(test)
str(test)
head(test$VRlog)
rj_output = test$VRlog
# Make a list to store descriptions of each scalar present in each iteration.
alltypes <- vector(mode = "list", length = nrow(rj_output))
alltypes
allmrcas <- vector(mode = "list", length = nrow(rj_output))
loadRJ <- function(logfile, burnin = 0, thinning = 1) {
raw <- readLines(logfile)
rawhead <- strsplit(raw[1:(grep("\\bIt*\\b", raw) -1)], "\t")
rawtail <- strsplit(raw[grep("\\bIt*\\b", raw):length(raw)], "\t")
nms1 <- rawtail[[1]][1:7]
nms2 <- rawtail[[1]][8:length(rawtail[[1]])]
nms2 <- gsub(" ", "", nms2)
nms2 <- gsub("/", "", nms2)
for (i in 1:length(rawtail)) {
if (length(rawtail[[i]]) == 7) {
names(rawtail[[i]]) <- nms1
} else {
len <- length(rawtail[[i]][8:length(rawtail[[i]])])
end <- vector(mode = "character", length = len)
st <- 1
ed <- 4
for (j in 1:(len/4)) {
end[c(st:ed)] <- paste(nms2, j, sep = "_")
st <- st + 4
ed <- ed + 4
}
nms <- c(nms1, end)
names(rawtail[[i]]) <- nms
}
}
tipnum <- rawhead[[1]]
taxatrans <- do.call(rbind, rawhead[c(1:tipnum+1)])
subtreestart <- nrow(taxatrans) + 3
subtrees <- rawhead[subtreestart:length(rawhead)]
for (i in 1:length(subtrees)) {
names(subtrees[[i]]) <- c(1:length(subtrees[[i]]))
}
output <- do.call(smartBind, rawtail)
output <- output[seq.int(burnin, nrow(output), thinning), ]
output <- data.frame(output[2:nrow(output), ], stringsAsFactors = FALSE)
subtrees <- do.call(smartBind, subtrees)
subtrees <- data.frame(subtrees, stringsAsFactors = FALSE)
colnames(subtrees)[c(1:2)] <- c("node", "bl")
res <- list(taxatrans, subtrees, output)
names(res) <- c("taxa", "subtrees", "rj_output")
return(res)
}
testhenry = loadRJ(vrfile)
smartBind <- function (...) {
# from GSee http://stackoverflow.com/questions/17308551/do-callrbind-list-for-uneven-number-of-column
dargs <- list(...)
if (!all(vapply(dargs, is.vector, TRUE)))
stop("all inputs must be vectors")
if (!all(vapply(dargs, function(x) !is.null(names(x)), TRUE)))
stop("all input vectors must be named.")
all.names <- unique(names(unlist(dargs)))
out <- do.call(rbind, lapply(dargs, `[`, all.names))
colnames(out) <- all.names
out
}
testhenry = loadRJ(vrfile)
head(testhenry$rj_output)
rjlog = vrfile
rjtrees = "test-001.txt.Output.trees"
tree = "marsupials.trees"
if (class(tree) == "phylo") {
extree <- ladderize(tree)
} else {
extree <- ladderize(read.nexus(tree))
}
extree
print("Loading log file.")
rjout <- loadRJ(rjlog, burnin = burnin, thinning = thinning)
burnin=0
thinning=1
meanbranches=TRUE
ratestable=TRUE
print("Loading log file.")
rjout <- loadRJ(rjlog, burnin = burnin, thinning = thinning)
rjout
print("Loading posterior trees.")
posttrees <- read.nexus(rjtrees)
posttrees <- posttrees[burnin:length(posttrees)]
if (meanbranches) {
print("Calculating mean branch lengths.")
meanbl <- meanBranches(reftree = extree, trees = posttrees, burnin = burnin,
thinning = thinning, pbar = TRUE)
} else {
meanbl = FALSE
}
meanBranches <- function(reftree, trees, burnin = 0, thinning = 1, pbar = FALSE) {
reftree <- ladderize(reftree)
if (class(trees) == "multiPhylo") {
trees <- trees
} else {
trees <- read.nexus(trees)
}
trees <- trees[seq.int(burnin, length(trees), thinning)]
#bls <- vector(mode = "numeric", length = length(reftree$edge.length))
bls <- matrix(nrow = length(reftree$edge.length), ncol = length(trees))
if (pbar) {
pb <- txtProgressBar(min = 0, max = length(trees), style = 3)
}
for (i in 1:length(trees)) {
tree <- ladderize(trees[[i]])
if (sum(reftree$tip.label == tree$tip.label) != length(reftree$tip.label)) {
stop(paste("Tip labels on tree", i, "do not mactch reference tree"))
}
if (sum(reftree$edge == tree$edge) != length(reftree$edge)) {
stop(paste("Tree", i, "has a different topology to reference tree"))
}
bls[ , i] <- tree$edge.length
if (pbar) {
setTxtProgressBar(pb, i)
}
}
rangebl <- vector(mode = "numeric", length = nrow(bls))
quart25 <- vector(mode = "numeric", length = nrow(bls))
quart75 <- vector(mode = "numeric", length = nrow(bls))
branchesmean <- vector(mode = "numeric", length(nrow(bls)))
branchesmedian <- vector(mode = "numeric", length(nrow(bls)))
for (i in 1:nrow(bls)) {
branchesmean[i] <- mean(bls[i, ])
branchesmedian[i] <- median(bls[i, ])
quarts <- sort(bls[i, ])
quart25[i] <- quarts[round(length(quarts) * 0.25)]
quart75[i] <- quarts[round(length(quarts) * 0.75)]
rangebl[i] <- max(bls[i, ]) - min(bls[i, ])
}
meantree <- reftree
meantree$edge.length <- branchesmean
res <- list(ogtree = reftree,
meantree = meantree,
meanbranches = branchesmean,
medianbranches = branchesmedian,
quart25 = quart25,
quart75 = quart75,
rangescalar = rangebl)
if (pbar) {
close(pb)
}
return(res)
}
if (meanbranches) {
print("Calculating mean branch lengths.")
meanbl <- meanBranches(reftree = extree, trees = posttrees, burnin = burnin,
thinning = thinning, pbar = TRUE)
} else {
meanbl = FALSE
}
rj_output <- rjout$rj_output
subtrees <- rjout$subtrees
rjtaxa <- rjout$taxa
niter <- nrow(rj_output)
print("Finding taxa.")
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
??pblapply
library(pbapply)
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
library(hfgr)
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
getTaxa
?getTaxa
getTaxa <- function(x, subtrees) {
taxa <- subtrees[subtrees$node == x, ]
taxa <- taxa[ , !is.na(taxa)]
taxa <- taxa[c(4:length(taxa))]
return(as.numeric(unlist(taxa)))
}
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
taxa
taxa[[1]]
taxa[[2]]
ls()
str(test)
taxa[[2]]
test$branchdef
test$branchdef[[2]]
taxa[[2]]
testhenry$subtrees[[2]]
testhenry$subtrees[[3]]
testhenry$subtrees
str(testhenry$subtrees)
testhenry$subtrees[3,]
testhenry$subtrees[2,]
testhenry$subtrees[1,]
test$branchdef[1]
subtrees
subtrees[1,]
subtrees[[1]]
names(subtrees)
c(1:length(subtrees[[i]]))
i =1
c(1:length(subtrees[[i]]))
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
getTaxa
i =2
c(1:length(subtrees[[i]]))
i = 3
c(1:length(subtrees[[i]]))
subtrees[[i]]
str(subtrees)
nrow(subtrees)
ncol(subtrees)
nrow(test$branchdef)
str(test$branchdef)
length(test$branchdef)
length(test[[1]])
test[[1]]
length(test$branchdef[[1]])
test$branchdef[[1]]
test$taxdef
vrfile
# Read full input file
vrraw = readLines(vrfile)
# Number of taxa
ntax = as.numeric(vrraw[1])
# Identify taxa definitions
txdef = read.table(vrfile, skip = 1, nrows = ntax,
sep = "\t",  header = F, col.names = c("TaxNo", "Tax"))
# Number of nodes
nnode = as.numeric(vrraw[ntax+2])
# Identify node definition block
nddef = vrraw[(ntax+3):(nnode+ntax+2)]
nddef = lapply(nddef, function(x)unlist(strsplit(x, split = "\t")))
nddef
ndInfo = sapply(nddef, "[[", 1:3)
ndInfo = sapply(nddef, "[[", c(1:3))
sapply(nddef, "[[", head, 3)
sapply(nddef, head, 3)
t(sapply(nddef, head, 3))
data.frame(t(sapply(nddef, head, 3)))
?data.frame
data.frame(t(sapply(nddef, head, 3)), row.names = NULL)
library(BayesTraitR)
ls()
# Test case
vrfile = "test-001.txt.VarRates.txt"
test = readVR(vrfile)
test
str(test)
rj_output <- rjout$rj_output
subtrees <- rjout$subtrees
rjtaxa <- rjout$taxa
niter <- nrow(rj_output)
print("Finding taxa.")
taxa <- pblapply(subtrees$node, function(x) getTaxa(x, subtrees = subtrees))
taxa
taxa[[1]]
test$taxdef[[1]]
all(taxa[[1]] %in% test$taxdef[[1]])
getMRCAhfg
getMRCAhfg <- function(x, tree, rjtaxa) {
if (length(x) == 1) {
mrca <- which(tree$tip.label == rjtaxa[rjtaxa[ , 1] %in% x, 2])
} else {
mrca <- getMRCA(tree, rjtaxa[rjtaxa[ , 1] %in% x, 2])
}
return(mrca)
}
fullmrcas <- unlist(pblapply(taxa, function(x) getMRCAhfg(x , tree = extree, rjtaxa = rjtaxa)))
fullmrcas <- data.frame(node = subtrees$node, mrca = fullmrcas)
head(fullmrcas)
findMRCA
library(phytools)
findMRCA
?getMRCA
# Make a list to store descriptions of each scalar present in each iteration.
alltypes <- vector(mode = "list", length = nrow(rj_output))
allmrcas <- vector(mode = "list", length = nrow(rj_output))
alltypes
nrow(rj_output)
head(rj_output)
rates <- matrix(rep(1, nrow(counts) * nrow(rj_output)), ncol = nrow(rj_output))
counts <- createCountsTable(extree, meanbl)
createCountsTable <- function(extree, meanbl) {
counts <- matrix(ncol = 52, nrow = (nrow(extree$edge) + 1))
colnames(counts) <- c("branch", "ancNode", "descNode", "nTips", "start", "end", "mid", "orgBL", "meanBL", "medianBL", "quart25", "quart75",
"itersScaled", "itersRatescaled", "itersDelta", "itersKappa", "itersLambda",
"pScaled", "pRate", "pDelta", "pKappa", "pLambda",
"nScalar", "nRate", "nDelta", "nKappa", "nLambda",
"nOrgnScalar", "nOrgnNRate", "nOrgnBRate", "nOrgnDelta", "nOrgnKappa", "nOrgnLambda",
"rangeRate", "lqRate", "uqRate", "meanRate", "medianRate", "modeRate",
"rangeDelta", "meanDelta", "medianDelta", "modeDelta",
"rangeKappa", "meanKappa", "medianKappa", "modeKappa",
"rangeLambda", "meanLambda", "medianLambda", "modeLambda", "species")
counts[ , "branch"] <- c(0:nrow(extree$edge))
counts[ , "ancNode"] <- c(0, extree$edge[ , 1])
counts[ , "descNode"] <- c((length(extree$tip.label) + 1), extree$edge[ , 2])
counts[ , "orgBL"] <- c(0, extree$edge.length)
if (is.list(meanbl)) {
counts[ , "meanBL"] <- c(0, meanbl$meanbranches)
counts[ , "medianBL"] <- c(0, meanbl$medianbranches)
counts[ , "quart25"] <- c(0, meanbl$quart25)
counts[ , "quart75"] <- c(0, meanbl$quart75)
} else {
counts[ , "meanBL"] <- rep(1, nrow(counts))
counts[ , "medianBL"] <- rep(1, nrow(counts))
counts[ , "quart25"] <- rep(1, nrow(counts))
counts[ , "quart75"] <- rep(1, nrow(counts))
}
hts <- nodeHeights(extree)
hts <- round(abs(hts - max(hts)), 4)
counts[ , "start"] <- c(0, hts[ , 1])
counts[ , "end"] <- c(0, hts[ , 2])
counts <- as.data.frame(counts)
# Deal with the root
descs <- getDescs(extree, node = counts[1, "descNode"])
counts[1, "nTips"] <- sum(descs <= length(extree$tip.label))
counts[1, "mid"] <- 0
counts[1, "species"] <- paste0(extree$tip.label[order(extree$tip.label)], collapse = ",")
for (i in 2:nrow(counts)) {
descs <- getDescs(extree, node = counts[i, "descNode"])
counts[i, "nTips"] <- sum(descs <= length(extree$tip.label))
if (counts[i, "nTips"] == 0) {
counts[i, "nTips"] <- 1
}
if (counts[i, "descNode"] <= length(extree$tip.label)) {
counts[i, "species"] <- extree$tip.label[counts[i, "descNode"]]
} else {
tips <- getDescs(extree, counts[i, "descNode"])
tips <- tips[tips <= length(extree$tip.label)]
tips <- extree$tip.label[tips]
counts[i, "species"] <- paste0(sort(tips), collapse = ",")
}
counts[i, "mid"] <- mean(c(hts[(i - 1), 1], hts[(i - 1), 2]))
}
counts[ , c(13:51)] <- 0
return(counts)
}
counts <- createCountsTable(extree, meanbl)
counts
head(counts)
str(counts)
str(test)
head(test$branchinfo)
test$taxdef[[3]]
test$taxdef[3]
test$branchdef[3]
test$taxdef[test$taxdef$TaxNo %in% c(0,1),]
tree = ladderize(read.nexus("marsupials.trees"))
which(tree$edge[,2] == 2)
library(JBfunctions)
tipDescendants(tree, 332)
tipDescendants(tree, 2)
which(tree$edge[,1] == 2)
counts <- createCountsTable(extree, meanbl)
# Make a list to store descriptions of each scalar present in each iteration.
alltypes <- vector(mode = "list", length = nrow(rj_output))
allmrcas <- vector(mode = "list", length = nrow(rj_output))
rates <- matrix(rep(1, nrow(counts) * nrow(rj_output)), ncol = nrow(rj_output))
rownames(rates) <- counts[ , "descNode"]
rates
nrow(rates)
ncol(rates)
ls()
str(test)
nrow(test$VRlog)
unique(test$VRlog$It)
tree$edge
tree = ladderize(read.nexus("marsupials.trees"))
tree$edge
# Create a branch info table
branchinfo = data.frame(tree$edge)
head(branchinfo)
# Create a branch info table
branchinfo = data.frame(tree$edge); colnames(branchinfo) = c("Anc", "Desc")
branchinfo$branch = 1:Nedge(tree)
# Create a branch info table
branchinfo = data.frame(tree$edge); colnames(branchinfo) = c("anc", "des")
branchinfo$br = 1:Nedge(tree)
branchinfo$brlength = tree$edge.length
head(branchinfo)
str(test)
head(test$branchinfo)
head(branchinfo)
## get the number of descendants for each tip or node:
nr_desc <- function(x) {
res <- numeric(max(x$edge))
res[1:Ntip(x)] <- 1L
for (i in postorder(x)) {
tmp <- x$edge[i,1]
res[tmp] <- res[tmp] + res[x$edge[i, 2]]
}
res
}
ttree <- rtree(10)
plot(ttree, show.tip.label = FALSE)
tiplabels()
nodelabels()
nr_desc(ttree)
res = numeric(max(tree$edge))
res
?numeric
tree$edge
numeric(max(ttree$edge))
?max
res[1:Ntip(x)] <- 1L
res[1:Ntip(tree)] <- 1L
res
postorder
?postorder
postorder(test)
postorder(tree)
i = 331
x$edge[i,1]
tree$edge[i,1]
tree
?postorder
res = numeric(max(tree$edge))
res[1:Ntip(tree)] <- 1L
for(i in 1:Nedge(tree)){
tmp = tree$edge[i,1]
res[tmp] = res[tmp] + res[tree$edge[i,2]]
}
res
phytools::getDescendants(tree)
?getDescendants
